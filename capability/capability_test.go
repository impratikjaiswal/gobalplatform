package capability

import (
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/skythen/gobalplatform/aid"
	"github.com/skythen/gobalplatform/internal/util"
	"github.com/skythen/gobalplatform/open"
	"github.com/skythen/gobalplatform/security"
)

func TestParseCardRecognitionData(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *SecurityDomainManagementData
		expectError bool
	}{
		{
			name:       "2.2.1 with SCP02",
			inputBytes: []byte{0x66, 0x4C, 0x73, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x9F, 0x65, 0x01, 0xFF},
			expected: &SecurityDomainManagementData{
				GPVersion:                   "2.2.1",
				CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
				SCPOptions: &SCPParameters{
					SCP02: []security.SCP02Parameter{
						{
							ThreeSCKeys:                true,
							CMACOnUnmodifiedAPDU:       false,
							ExplicitInitiation:         true,
							ICVMacOverAID:              false,
							ICVEncryptionForCMAC:       true,
							RMACSupported:              false,
							KnownPseudoRandomAlgorithm: true,
						},
					},
					SCP03: nil,
				},
				CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
				CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
				SDTrustPointCertificateInformation: nil,
				SDCertificateInformation:           nil,
			},
			expectError: false,
		},
		{
			name:        "Error: invalid BER-TLV",
			inputBytes:  []byte{0x66, 0x4F, 0x73, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing card data tag",
			inputBytes:  []byte{0x65, 0x4C, 0x73, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing card recognition data tag",
			inputBytes:  []byte{0x66, 0x4C, 0x72, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid security domain management data",
			inputBytes:  []byte{0x66, 0x4C, 0x73, 0x4A, 0x06, 0x07, 0x2A, 0x88, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := ParseCardRecognitionData(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}

func TestParseSecurityDomainManagementData(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *SecurityDomainManagementData
		expectError bool
	}{
		{
			name:       "outer tag 0x73, GP version 2.2.1, SCP02",
			inputBytes: []byte{0x73, 0x54, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x67, 0x03, 0x0A, 0x01, 0x0F, 0x68, 0x03, 0x0B, 0x01, 0x0F},
			expected: &SecurityDomainManagementData{
				GPVersion:                   "2.2.1",
				CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
				SCPOptions: &SCPParameters{
					SCP02: []security.SCP02Parameter{
						{
							ThreeSCKeys:                true,
							CMACOnUnmodifiedAPDU:       false,
							ExplicitInitiation:         true,
							ICVMacOverAID:              false,
							ICVEncryptionForCMAC:       true,
							RMACSupported:              false,
							KnownPseudoRandomAlgorithm: true,
						},
					},
					SCP03: nil,
					SCP10: nil,
				},
				CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
				CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
				SDTrustPointCertificateInformation: []byte{0x67, 0x03, 0x0A, 0x01, 0x0F},
				SDCertificateInformation:           []byte{0x68, 0x03, 0x0B, 0x01, 0x0F},
			},
			expectError: false,
		},
		{
			name:       "GP version 2.2.1, SCP02",
			inputBytes: []byte{0x73, 0x54, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x67, 0x03, 0x0A, 0x01, 0x0F, 0x68, 0x03, 0x0B, 0x01, 0x0F},
			expected: &SecurityDomainManagementData{
				GPVersion:                   "2.2.1",
				CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
				SCPOptions: &SCPParameters{
					SCP02: []security.SCP02Parameter{
						{
							ThreeSCKeys:                true,
							CMACOnUnmodifiedAPDU:       false,
							ExplicitInitiation:         true,
							ICVMacOverAID:              false,
							ICVEncryptionForCMAC:       true,
							RMACSupported:              false,
							KnownPseudoRandomAlgorithm: true,
						},
					},
					SCP03: nil,
					SCP10: nil,
				},
				CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
				CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
				SDTrustPointCertificateInformation: []byte{0x67, 0x03, 0x0A, 0x01, 0x0F},
				SDCertificateInformation:           []byte{0x68, 0x03, 0x0B, 0x01, 0x0F},
			},
			expectError: false,
		},
		{
			name:       "GP version 2.2.1, SCP02+SCP03+SCP10",
			inputBytes: []byte{0x73, 0x6A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x21, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x03, 0x10, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x10, 0x01, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x67, 0x03, 0x0A, 0x01, 0x0F, 0x68, 0x03, 0x0B, 0x01, 0x0F},
			expected: &SecurityDomainManagementData{
				GPVersion:                   "2.2.1",
				CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
				SCPOptions: &SCPParameters{
					SCP02: []security.SCP02Parameter{
						{
							ThreeSCKeys:                true,
							CMACOnUnmodifiedAPDU:       false,
							ExplicitInitiation:         true,
							ICVMacOverAID:              false,
							ICVEncryptionForCMAC:       true,
							RMACSupported:              false,
							KnownPseudoRandomAlgorithm: true,
						},
					},
					SCP03: []security.SCP03Parameter{
						{
							PseudoRandomCardChallenge: true,
							RMACSupport:               false,
							RENCSupport:               false,
						},
					},
					SCP10: []security.SCP10Parameter{
						{
							KeyAgreement:                    true,
							SignatureWithoutMessageRecovery: false,
						},
					},
				},
				CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
				CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
				SDTrustPointCertificateInformation: []byte{0x67, 0x03, 0x0A, 0x01, 0x0F},
				SDCertificateInformation:           []byte{0x68, 0x03, 0x0B, 0x01, 0x0F},
			},
			expectError: false,
		},
		{
			name:       "GP version 2.2.1, unknown SCPs",
			inputBytes: []byte{0x73, 0x5F, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x16, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x12, 0xFF, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x13, 0xEE, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x67, 0x03, 0x0A, 0x01, 0x0F, 0x68, 0x03, 0x0B, 0x01, 0x0F},
			expected: &SecurityDomainManagementData{
				GPVersion:                   "2.2.1",
				CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
				SCPOptions: &SCPParameters{
					SCP02: nil,
					SCP03: nil,
					SCP10: nil,
					Other: []security.SCPParameter{
						{
							ID:     0x12,
							Option: 0xFF,
						},
						{
							ID:     0x13,
							Option: 0xEE,
						},
					},
				},
				CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
				CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
				SDTrustPointCertificateInformation: []byte{0x67, 0x03, 0x0A, 0x01, 0x0F},
				SDCertificateInformation:           []byte{0x68, 0x03, 0x0B, 0x01, 0x0F},
			},
			expectError: false,
		},
		{
			name:       "GP version 2.3, SCP02, 2 byte GP version",
			inputBytes: []byte{0x73, 0x53, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x03, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x67, 0x03, 0x0A, 0x01, 0x0F, 0x68, 0x03, 0x0B, 0x01, 0x0F},
			expected: &SecurityDomainManagementData{
				GPVersion:                   "2.3",
				CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
				SCPOptions: &SCPParameters{
					SCP02: []security.SCP02Parameter{
						{
							ThreeSCKeys:                true,
							CMACOnUnmodifiedAPDU:       false,
							ExplicitInitiation:         true,
							ICVMacOverAID:              false,
							ICVEncryptionForCMAC:       true,
							RMACSupported:              false,
							KnownPseudoRandomAlgorithm: true,
						},
					},
					SCP03: nil,
					SCP10: nil,
				},
				CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
				CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
				SDTrustPointCertificateInformation: []byte{0x67, 0x03, 0x0A, 0x01, 0x0F},
				SDCertificateInformation:           []byte{0x68, 0x03, 0x0B, 0x01, 0x0F},
			},
			expectError: false,
		},
		{
			name:        "Error: missing tag 0x73",
			inputBytes:  []byte{0x74, 0x54, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03, 0x67, 0x03, 0x0A, 0x01, 0x0F, 0x68, 0x03, 0x0B, 0x01, 0x0F},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid BER-TLV",
			inputBytes:  []byte{0x73, 0x43, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid tag",
			inputBytes:  []byte{0x74, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing tag OID 1",
			inputBytes:  []byte{0x73, 0x4A, 0x05, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: OID 1 unequal GP OID",
			inputBytes:  []byte{0x73, 0x4A, 0x06, 0x07, 0x2B, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid Version length in GP OID 2",
			inputBytes:  []byte{0x73, 0x4B, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0D, 0x06, 0x0B, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x02, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid GP OID 3 for card identification scheme",
			inputBytes:  []byte{0x73, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2B, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid GP OID 4 for ISD SCPs",
			inputBytes:  []byte{0x73, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2B, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing i param in GP OID 4 for ISD SCPs",
			inputBytes:  []byte{0x73, 0x49, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := ParseSecurityDomainManagementData(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}

func TestParseSCPInformation(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *SCPInformation
		expectError bool
	}{
		{
			name:       "SCP02 Information",
			inputBytes: []byte{0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55},
			expected: &SCPInformation{
				Type:                          2,
				SupportedOptions:              []byte{0x15, 0x55},
				SCP03SupportedKeys:            nil,
				SCP81SupportedTLSCipherSuites: nil,
				SCP81MaxLengthPreSharedKey:    util.NullByte{},
			},
			expectError: false,
		},
		{
			name:       "SCP03 Information",
			inputBytes: []byte{0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07},
			expected: &SCPInformation{
				Type:             3,
				SupportedOptions: []byte{0x15, 0x55},
				SCP03SupportedKeys: &SCP03SupportedKeys{
					AES128: true,
					AES192: true,
					AES256: true,
				},
				SCP81SupportedTLSCipherSuites: nil,
				SCP81MaxLengthPreSharedKey:    util.NullByte{},
			},
			expectError: false,
		},
		{
			name:       "SCP81 Information",
			inputBytes: []byte{0xA0, 0x10, 0x80, 0x01, 0x81, 0x81, 0x02, 0x15, 0x55, 0x83, 0x04, 0xFF, 0xFF, 0xEE, 0xEE, 0x84, 0x01, 0x05},
			expected: &SCPInformation{
				Type:                          0x81,
				SupportedOptions:              []byte{0x15, 0x55},
				SCP03SupportedKeys:            nil,
				SCP81SupportedTLSCipherSuites: [][]byte{{0xFF, 0xFF}, {0xEE, 0xEE}},
				SCP81MaxLengthPreSharedKey:    util.NullByte{Byte: 0x05, Valid: true},
			},
			expectError: false,
		},
		{
			name:       "unknown SCP type",
			inputBytes: []byte{0xA0, 0x07, 0x80, 0x01, 0x98, 0x81, 0x02, 0x15, 0x55},
			expected: &SCPInformation{
				Type:                          0x98,
				SupportedOptions:              []byte{0x15, 0x55},
				SCP03SupportedKeys:            nil,
				SCP81SupportedTLSCipherSuites: nil,
				SCP81MaxLengthPreSharedKey: util.NullByte{
					Byte:  0,
					Valid: false,
				},
			},
			expectError: false,
		},
		{
			name:        "Error: invalid tlv",
			inputBytes:  []byte{0xA0, 0x09, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Missing SCP Information Tag",
			inputBytes:  []byte{0xB0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Missing SCP Type Tag",
			inputBytes:  []byte{0xA0, 0x07, 0x82, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Invalid SCP Type length",
			inputBytes:  []byte{0xA0, 0x08, 0x80, 0x02, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Missing SCP Option Tag",
			inputBytes:  []byte{0xA0, 0x07, 0x80, 0x01, 0x02, 0x83, 0x02, 0x15, 0x55},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Missing Supported Keys for SCP03 Tag",
			inputBytes:  []byte{0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x84, 0x01, 0x07},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Invalid Supported Keys for SCP03 length",
			inputBytes:  []byte{0xA0, 0x0B, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x02, 0x07, 0x08},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Missing Supported Cipher Suites for SCP81 Tag",
			inputBytes:  []byte{0xA0, 0x0E, 0x80, 0x01, 0x81, 0x81, 0x02, 0x15, 0x55, 0x82, 0x02, 0xFF, 0xFF, 0x84, 0x01, 0x05},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Invalid length of Supported Cipher Suites for SCP81",
			inputBytes:  []byte{0xA0, 0x0F, 0x80, 0x01, 0x81, 0x81, 0x02, 0x15, 0x55, 0x83, 0x03, 0xFF, 0xFF, 0xFF, 0x84, 0x01, 0x05},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: Missing maximum length of pre shared key for SCP81",
			inputBytes:  []byte{0xA0, 0x0E, 0x80, 0x01, 0x81, 0x81, 0x02, 0x15, 0x55, 0x83, 0x02, 0xFF, 0xFF, 0x85, 0x01, 0x05},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid length of pre shared key for SCP81",
			inputBytes:  []byte{0xA0, 0x10, 0x80, 0x01, 0x81, 0x81, 0x02, 0x15, 0x55, 0x83, 0x02, 0xFF, 0xFF, 0x84, 0x03, 0x05, 0x04, 0x03},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := ParseSCPInformation(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}

func TestParseCipherSuitesForLFDBEncryption(t *testing.T) {
	tests := []struct {
		name      string
		inputByte byte
		expected  *CipherSuitesForLFDBEncryption
	}{
		{
			name:      "All cipher suites",
			inputByte: 0x8F,
			expected: &CipherSuitesForLFDBEncryption{
				TripleDES16Byte:      true,
				AES128:               true,
				AES192:               true,
				AES256:               true,
				ICVForLFDBEncryption: true,
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received := ParseCipherSuitesForLFDBEncryption(tc.inputByte)

			if !cmp.Equal(tc.expected, received) {
				t.Errorf("Expected: '%v', got: '%v'", tc.expected, received)
			}
		})
	}
}

func TestParseCipherSuitesForSignature(t *testing.T) {
	tests := []struct {
		name       string
		inputBytes [2]byte
		expected   *CipherSuitesForSignature
	}{
		{
			name:       "All cipher suites",
			inputBytes: [2]byte{0xFF, 0x03},
			expected: &CipherSuitesForSignature{
				Rsa1024SsaPkcsV15SHA1:            true,
				RsaSsaPssSHA256:                  true,
				SingleDESPlusFinalTripleDESMac16: true,
				CmacAES128:                       true,
				CmacAES192:                       true,
				CmacAES256:                       true,
				ECDSAWithEC256AndSHA256:          true,
				ECDSAWithEC384AndSHA384:          true,
				ECDSAWithEC512AndSHA512:          true,
				ECDSAWithEC521AndSHA512:          true,
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received := ParseCipherSuitesForSignature(tc.inputBytes)

			if !cmp.Equal(tc.expected, received) {
				t.Errorf("Expected: '%v', got: '%v'", tc.expected, received)
			}
		})
	}
}

func TestParseKeyParameterReferenceValues(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *KeyParameterReferenceValues
		expectError bool
	}{
		{
			name:       "all fields",
			inputBytes: []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected: &KeyParameterReferenceValues{
				P256:            true,
				P384:            true,
				P521:            true,
				BrainpoolP256r1: true,
				BrainpoolP256t1: true,
				BrainpoolP384r1: true,
				BrainpoolP384t1: true,
				BrainpoolP512r1: true,
				BrainpoolP512t1: true,
				ProprietaryGlobalReferences: [][]byte{
					{0x40},
					{0x5F},
					{0xC0, 0x00},
					{0xDF, 0xFF},
				},
				LocalKeyParameterReferences: [][]byte{
					{0x60},
					{0x7F},
					{0xE0, 0x00},
					{0xFF, 0xFF},
				},
			},
			expectError: false,
		},
		{
			name:        "Error: invalid global references",
			inputBytes:  []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF, 0xDF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid local references",
			inputBytes:  []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := ParseKeyParameterReferenceValues(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}

func TestParseCardCapabilityInformation(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *CardCapabilityInformation
		expectError bool
	}{
		{
			name:       "Full Capability Information",
			inputBytes: []byte{0x67, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected: &CardCapabilityInformation{
				SCPInformation: []SCPInformation{
					{
						Type:             2,
						SupportedOptions: []byte{0x15, 0x55},
					},
					{
						Type:             3,
						SupportedOptions: []byte{0x15, 0x55},
						SCP03SupportedKeys: &SCP03SupportedKeys{
							AES128: true,
							AES192: true,
							AES256: true,
						},
					},
				},
				AssignableSSDPrivileges: open.Privileges{
					open.SecurityDomain,
					open.DAPVerification,
					open.DelegatedManagement,
					open.CardLock,
					open.CardTerminate,
					open.CardReset,
					open.CVMManagement,
					open.TrustedPath,
					open.AuthorizedManagement,
					open.TokenVerification,
					open.GlobalDelete,
					open.GlobalLock,
					open.GlobalRegistry,
					open.FinalApplication,
					open.GlobalService,
					open.ReceiptGeneration,
					open.CipheredLoadFileDataBlock,
					open.ContactlessActivation,
					open.ContactlessSelfActivation,
				},
				AssignableApplicationPrivileges: open.Privileges{
					open.SecurityDomain,
					open.DAPVerification,
					open.DelegatedManagement,
					open.CardLock,
					open.CardTerminate,
					open.CardReset,
					open.CVMManagement,
					open.TrustedPath,
					open.AuthorizedManagement,
					open.TokenVerification,
					open.GlobalDelete,
					open.GlobalLock,
					open.GlobalRegistry,
					open.FinalApplication,
					open.GlobalService,
					open.ReceiptGeneration,
					open.CipheredLoadFileDataBlock,
					open.ContactlessActivation,
					open.ContactlessSelfActivation,
				},
				LFDBHAlgorithms: SupportedLFDBHAlgorithms{
					SHA1:   true,
					SHA256: true,
					SHA384: true,
					SHA512: true,
				},
				CipherSuitesLFDBEnc: &CipherSuitesForLFDBEncryption{
					TripleDES16Byte:      true,
					AES128:               true,
					AES192:               true,
					AES256:               true,
					ICVForLFDBEncryption: true,
				},
				CipherSuitesTokens: &CipherSuitesForSignature{
					Rsa1024SsaPkcsV15SHA1:            true,
					RsaSsaPssSHA256:                  true,
					SingleDESPlusFinalTripleDESMac16: true,
					CmacAES128:                       true,
					CmacAES192:                       true,
					CmacAES256:                       true,
					ECDSAWithEC256AndSHA256:          true,
					ECDSAWithEC384AndSHA384:          true,
					ECDSAWithEC512AndSHA512:          true,
					ECDSAWithEC521AndSHA512:          true,
				},
				CipherSuitesReceipts: &CipherSuitesForSignature{
					Rsa1024SsaPkcsV15SHA1:            true,
					RsaSsaPssSHA256:                  true,
					SingleDESPlusFinalTripleDESMac16: true,
					CmacAES128:                       true,
					CmacAES192:                       true,
					CmacAES256:                       true,
					ECDSAWithEC256AndSHA256:          true,
					ECDSAWithEC384AndSHA384:          true,
					ECDSAWithEC512AndSHA512:          true,
					ECDSAWithEC521AndSHA512:          true,
				},
				CipherSuitesDAPs: &CipherSuitesForSignature{
					Rsa1024SsaPkcsV15SHA1:            true,
					RsaSsaPssSHA256:                  true,
					SingleDESPlusFinalTripleDESMac16: true,
					CmacAES128:                       true,
					CmacAES192:                       true,
					CmacAES256:                       true,
					ECDSAWithEC256AndSHA256:          true,
					ECDSAWithEC384AndSHA384:          true,
					ECDSAWithEC512AndSHA512:          true,
					ECDSAWithEC521AndSHA512:          true,
				},
				KeyParameterReferenceList: &KeyParameterReferenceValues{
					P256:            true,
					P384:            true,
					P521:            true,
					BrainpoolP256r1: true,
					BrainpoolP256t1: true,
					BrainpoolP384r1: true,
					BrainpoolP384t1: true,
					BrainpoolP512r1: true,
					BrainpoolP512t1: true,
					ProprietaryGlobalReferences: [][]byte{
						{0x40},
						{0x5F},
						{0xC0, 0x00},
						{0xDF, 0xFF},
					},
					LocalKeyParameterReferences: [][]byte{
						{0x60},
						{0x7F},
						{0xE0, 0x00},
						{0xFF, 0xFF},
					},
				},
			},
			expectError: false,
		},
		{
			name:       "Capability Information 1B Cipher Suites",
			inputBytes: []byte{0x67, 0x48, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x01, 0xFF, 0x86, 0x01, 0xFF, 0x87, 0x01, 0xFF, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected: &CardCapabilityInformation{
				SCPInformation: []SCPInformation{
					{
						Type:             2,
						SupportedOptions: []byte{0x15, 0x55},
					},
					{
						Type:             3,
						SupportedOptions: []byte{0x15, 0x55},
						SCP03SupportedKeys: &SCP03SupportedKeys{
							AES128: true,
							AES192: true,
							AES256: true,
						},
					},
				},
				AssignableSSDPrivileges: open.Privileges{
					open.SecurityDomain,
					open.DAPVerification,
					open.DelegatedManagement,
					open.CardLock,
					open.CardTerminate,
					open.CardReset,
					open.CVMManagement,
					open.TrustedPath,
					open.AuthorizedManagement,
					open.TokenVerification,
					open.GlobalDelete,
					open.GlobalLock,
					open.GlobalRegistry,
					open.FinalApplication,
					open.GlobalService,
					open.ReceiptGeneration,
					open.CipheredLoadFileDataBlock,
					open.ContactlessActivation,
					open.ContactlessSelfActivation,
				},
				AssignableApplicationPrivileges: open.Privileges{
					open.SecurityDomain,
					open.DAPVerification,
					open.DelegatedManagement,
					open.CardLock,
					open.CardTerminate,
					open.CardReset,
					open.CVMManagement,
					open.TrustedPath,
					open.AuthorizedManagement,
					open.TokenVerification,
					open.GlobalDelete,
					open.GlobalLock,
					open.GlobalRegistry,
					open.FinalApplication,
					open.GlobalService,
					open.ReceiptGeneration,
					open.CipheredLoadFileDataBlock,
					open.ContactlessActivation,
					open.ContactlessSelfActivation,
				},
				LFDBHAlgorithms: SupportedLFDBHAlgorithms{
					SHA1:   true,
					SHA256: true,
					SHA384: true,
					SHA512: true,
				},
				CipherSuitesLFDBEnc: &CipherSuitesForLFDBEncryption{
					TripleDES16Byte:      true,
					AES128:               true,
					AES192:               true,
					AES256:               true,
					ICVForLFDBEncryption: true,
				},
				CipherSuitesTokens: &CipherSuitesForSignature{
					Rsa1024SsaPkcsV15SHA1:            true,
					RsaSsaPssSHA256:                  true,
					SingleDESPlusFinalTripleDESMac16: true,
					CmacAES128:                       true,
					CmacAES192:                       true,
					CmacAES256:                       true,
					ECDSAWithEC256AndSHA256:          true,
					ECDSAWithEC384AndSHA384:          true,
					ECDSAWithEC512AndSHA512:          false,
					ECDSAWithEC521AndSHA512:          false,
				},
				CipherSuitesReceipts: &CipherSuitesForSignature{
					Rsa1024SsaPkcsV15SHA1:            true,
					RsaSsaPssSHA256:                  true,
					SingleDESPlusFinalTripleDESMac16: true,
					CmacAES128:                       true,
					CmacAES192:                       true,
					CmacAES256:                       true,
					ECDSAWithEC256AndSHA256:          true,
					ECDSAWithEC384AndSHA384:          true,
					ECDSAWithEC512AndSHA512:          false,
					ECDSAWithEC521AndSHA512:          false,
				},
				CipherSuitesDAPs: &CipherSuitesForSignature{
					Rsa1024SsaPkcsV15SHA1:            true,
					RsaSsaPssSHA256:                  true,
					SingleDESPlusFinalTripleDESMac16: true,
					CmacAES128:                       true,
					CmacAES192:                       true,
					CmacAES256:                       true,
					ECDSAWithEC256AndSHA256:          true,
					ECDSAWithEC384AndSHA384:          true,
					ECDSAWithEC512AndSHA512:          false,
					ECDSAWithEC521AndSHA512:          false,
				},
				KeyParameterReferenceList: &KeyParameterReferenceValues{
					P256:            true,
					P384:            true,
					P521:            true,
					BrainpoolP256r1: true,
					BrainpoolP256t1: true,
					BrainpoolP384r1: true,
					BrainpoolP384t1: true,
					BrainpoolP512r1: true,
					BrainpoolP512t1: true,
					ProprietaryGlobalReferences: [][]byte{
						{0x40},
						{0x5F},
						{0xC0, 0x00},
						{0xDF, 0xFF},
					},
					LocalKeyParameterReferences: [][]byte{
						{0x60},
						{0x7F},
						{0xE0, 0x00},
						{0xFF, 0xFF},
					},
				},
			},
			expectError: false,
		},
		{
			name:        "Error: invalid BER-TLV",
			inputBytes:  []byte{0x67, 0x4E, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing card capability information tag",
			inputBytes:  []byte{0x66, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing SCP information tag",
			inputBytes:  []byte{0x67, 0x4B, 0xA1, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA1, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid SCP information",
			inputBytes:  []byte{0x67, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x84, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing application privileges tag",
			inputBytes:  []byte{0x67, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x87, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid application privileges length",
			inputBytes:  []byte{0x67, 0x4C, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x04, 0x01, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid SSD privileges",
			inputBytes:  []byte{0x67, 0x4C, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x04, 0x02, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing LFDBH algorithms tag",
			inputBytes:  []byte{0x67, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x93, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid cipher suites for LFDB encryption length",
			inputBytes:  []byte{0x67, 0x4C, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x02, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid cipher suites for tokens length",
			inputBytes:  []byte{0x67, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x03, 0xFF, 0xFF, 0xFF, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid cipher suites for receipts length",
			inputBytes:  []byte{0x67, 0x4B, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x03, 0xFF, 0xFF, 0xFF, 0x87, 0x02, 0xFF, 0x03, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid cipher suites for DAPs length",
			inputBytes:  []byte{0x67, 0x4A, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x02, 0xFF, 0x03, 0x86, 0x02, 0xFF, 0x03, 0x87, 0x03, 0xFF, 0xFF, 0xFF, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid token cipher suites length",
			inputBytes:  []byte{0x67, 0x4A, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x03, 0xFF, 0xFE, 0xFD, 0x86, 0x01, 0xFF, 0x87, 0x01, 0xFF, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid receipt cipher suites length",
			inputBytes:  []byte{0x67, 0x4A, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x01, 0xFF, 0x86, 0x03, 0xFF, 0xFE, 0xFD, 0x87, 0x01, 0xFF, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid dap cipher suites length",
			inputBytes:  []byte{0x67, 0x4A, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x01, 0xFF, 0x86, 0x01, 0xFF, 0x87, 0x03, 0xFF, 0xFE, 0xFD, 0x88, 0x15, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0, 0x00, 0xFF, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid Key Reference Parameter list",
			inputBytes:  []byte{0x67, 0x45, 0xA0, 0x07, 0x80, 0x01, 0x02, 0x81, 0x02, 0x15, 0x55, 0xA0, 0x0A, 0x80, 0x01, 0x03, 0x81, 0x02, 0x15, 0x55, 0x82, 0x01, 0x07, 0x81, 0x03, 0xFE, 0xFF, 0xF0, 0x82, 0x03, 0xFE, 0xFF, 0xF0, 0x83, 0x04, 0x01, 0x02, 0x03, 0x04, 0x84, 0x01, 0x8F, 0x85, 0x01, 0xFF, 0x86, 0x01, 0xFF, 0x87, 0x01, 0xFF, 0x88, 0x12, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x40, 0x5F, 0xC0, 0x00, 0xDF, 0xFF, 0x60, 0x7F, 0xE0},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := ParseCardCapabilityInformation(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}

func TestParseFCI(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *FileControlInformation
		expectError bool
	}{
		{
			name: "valid",
			inputBytes: []byte{0x6F, 0x0D, 0x84, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05,
				0xA5, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected: &FileControlInformation{
				AID: aid.AID{0x01, 0x02, 0x03, 0x04, 0x05},
				ProprietaryData: ProprietaryData{
					SecurityDomainManagementData:       nil,
					ApplicationProductionLifeCycleData: nil,
					MaximumCommandDataFieldLength:      255,
				},
			},
			expectError: false,
		},
		{
			name: "Error: invalid tlv",
			inputBytes: []byte{0x6F, 0x0E, 0x84, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05,
				0xA5, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name: "Error: missing FCI tag",
			inputBytes: []byte{0x6E, 0x0D, 0x84, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05,
				0xA5, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name: "Error: missing AID tag",
			inputBytes: []byte{0x6F, 0x0D, 0x83, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05,
				0xA5, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name: "Error: invalid AID",
			inputBytes: []byte{0x6F, 0x0C, 0x84, 0x04, 0x01, 0x02, 0x03, 0x04,
				0xA5, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name: "Error: missing proprietary data",
			inputBytes: []byte{0x6F, 0x0D, 0x84, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05,
				0xA4, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name: "Error: invalid proprietary data",
			inputBytes: []byte{0x6F, 0x0D, 0x84, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05,
				0xA5, 0x04, 0x9F, 0x66, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := ParseFileControlInformation(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}

func TestParseProprietaryData(t *testing.T) {
	tests := []struct {
		name        string
		inputBytes  []byte
		expected    *ProprietaryData
		expectError bool
	}{
		{
			name:       "valid",
			inputBytes: []byte{0xA5, 0x58, 0x9F, 0x65, 0x01, 0xFF, 0x9F, 0x6E, 0x05, 0x01, 0x02, 0x03, 0x04, 0x05, 0x73, 0x4A, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x01, 0x60, 0x0C, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x02, 0x02, 0x01, 0x63, 0x09, 0x06, 0x07, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03, 0x64, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x04, 0x02, 0x55, 0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03, 0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
			expected: &ProprietaryData{
				SecurityDomainManagementData: &CardRecognitionData{
					GPVersion:                   "2.2.1",
					CardIdentificationSchemeOID: []byte{0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x03},
					SCPOptions: &SCPParameters{
						SCP02: []security.SCP02Parameter{
							{
								ThreeSCKeys:                true,
								CMACOnUnmodifiedAPDU:       false,
								ExplicitInitiation:         true,
								ICVMacOverAID:              false,
								ICVEncryptionForCMAC:       true,
								RMACSupported:              false,
								KnownPseudoRandomAlgorithm: true,
							},
						},
						SCP03: nil,
					},
					CardConfigurationDetails:           []byte{0x65, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xFC, 0x6B, 0x02, 0x01, 0x03},
					CardAndChipDetails:                 []byte{0x66, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x2A, 0x02, 0x6E, 0x01, 0x03},
					SDTrustPointCertificateInformation: nil,
					SDCertificateInformation:           nil,
				},
				ApplicationProductionLifeCycleData: []byte{0x01, 0x02, 0x03, 0x04, 0x05},
				MaximumCommandDataFieldLength:      255,
			},
			expectError: false,
		},
		{
			name:        "Error: invalid tlv",
			inputBytes:  []byte{0xA5, 0x05, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing proprietary data tag",
			inputBytes:  []byte{0xA4, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid Security Domain Management Data",
			inputBytes:  []byte{0xA5, 0x09, 0x73, 0x03, 0x05, 0x01, 0x01, 0x9F, 0x65, 0x01, 0x03},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: missing proprietary data",
			inputBytes:  []byte{0xA4, 0x04, 0x9F, 0x65, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
		{
			name:        "Error: invalid proprietary data",
			inputBytes:  []byte{0xA5, 0x04, 0x9F, 0x66, 0x01, 0xFF},
			expected:    nil,
			expectError: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			received, err := parseProprietaryData(tc.inputBytes)

			util.EvaluateTestWithError(t, tc.expectError, err, tc.expected, received)
		})
	}
}
